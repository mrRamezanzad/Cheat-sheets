Node.js is single-threaded but in the background it uses multiple threads to execute asynchronous code 
with the help of the libuv library.# scope is the current context of execution

# var gets hoisted undefined 
# let and constant won't get hoisted and from top to the initiation of let is named 'temporal dead zone'
# let and constant won't be accessed from the global object directly

# in nodejs global object is current module

# block scope came in es6 and can be created using curley brackets but var still can be accessed from global scope
even if it's defined in a block scope and we should use let instead 

# hoisting of a function is higher than a variable ex: assigning a function then a text to a var and accessing it before 
decleration gives us the function definition because of it's priority but after decleration we get 
the last one thats been assigned to variable which in this case is text and inside function scope arguments has the lowest priority

# function is an object that it's constructor is function constructor and has properties like:
: .name : which gives functions name
: .length : gives number of arguments
: .arguments : getting arguments which outside of function is null because arguments are also 
defined like a variable inside a function 
arguments is an indexed object that apart from argument values it has things like:
: callee : points to the function itself and it also can be alternative of functions name arguments.callee === myfunc //true
when using anonymous function (not arrow function) we can make it recursive using callee
arguments used to have a property named caller which is now part of function object and we can use it by callee.caller
: caller : tells us where a function is being invoked ex: in global scope returns null if call the function (call not define)
inside a function it returns the outer function
caller does not support block scope and inside if statements is still null which means global
: length : number of arguments
: Symbol.iterator : is an API that enables the indexed object to work with for of   (we access arguments with numeric index)
: __proto__ : prototype of arguments

: this : points to the owner object 
in a callback method it points to the window even if it's in an object and it causes problems
it is because a callback function is just a normal function thats been defined in window 
to solve it we use bind() at the end of callback method we can also use arrow function to solve this issue

: .bind() : copies a function with the target object and we can put arguments in it call(obj, arg1, arg2)
: currying : converting a multi argument function into series of single argument functions 
: call & apply : like bind but they invoke the funtion and apply gets arguments in a single array
: HOF (Higher order Functions) : they accept other functions as argument values or ruturn a function 
like forEach, map, filter, setTimeout() which all get function as argument value

# below is an example of currying to reduce validating the first number each time 
and we used HOF to make this function into single argument functions
function curryAdd (a) {
    if (!Number.isInteger(a)) throw 'illegal 1'st arg. val'
    return function(b) {
        if (!Number.isInteger(b)) throw 'illgal 2'nd arg. val'
        console.log(a+b)
    }
}

let step1 = curryAdd(1)
step1(3)
step1(4)


# before block scope we used closure to simiulate it 
cluser needs : 1- parent function 2- child function 3- two returns

: in arrow function : if there is just one line of code we don't put curley brackets
and it will auto returns that line of code (if put brackets you should return manually)
if wanna return object you should wrap it inside paranthesis msg => ({msg: "hello"})

# arrow function doesn't have 'this' and inherits it just from it's outer function or method (not outer object)

# second argument of forEach method lets us redirect 'this' of the callback like .bind()

# in destructureng we can skip middle parts (one or more) and get others
- let fruits = ['apple', 'orange', 'cranbarry']
- let [first, , last] = fruits # 

# we can destructure String as an array & object
- let str = 'hello ; 
[first, second, third] = str //first: h second: e third: l
({length} = str)  // output: 5 # we use paranthesis to bypass error of not declaring variable 

# Number can't be destructured as an array but can be used by its Object prototype
# Boolan is like number but have limited object prototype methods (toString, value)
# Null and doesn't have any object porototype either and can't be destructured

#====================== map and set
before ES6 we used array and object to store collection of data but no more with map and set
: MAP : is an enhanced version of an object which has no restriction on key name types which gives more storage power
and like array it remembers insetion order of it's key value pairs when adding and removing propeties is repeated scenario
map is more efficient than object
- let map = new Map([['fruit', 'apple'], ['vegan', 'celery']])
- map.set('diary', 'milk').set('meat', 'beaf')
- map.get('fruit') // output: apple
- map.size() // output: 4 # returns number of key value pairs
- map.has('vegan') // output: true
- map.delete('vegan') // output: true
- map.clear() # removes everything and gives us an empty map
- map.set(false, 'false as value') # no type restiction of keys (null, undefined, NaN)

# but if assign refrence values like array map.set([1,2,3], 'refrence val')
we cant use map.get([1,2,3]) and we should do something like 
- let arr = [1,2,3]
- map.set(arr, 'refrence val')
- map.get(arr)

# by using spread operator we can turn a map into a 2D array
- [...map]
another alternative is:
- Array.from(map)

#===================== for of
# works with iteratable types like string, array, array like objects, map & set
: array like objects : are special objects that use numeric index a property name
# for of on map makes it into pair of key value array but we can destructure it like 
- for ( [key, value] of map){}
- for (key of map.keys) # to just get keys
- for (value of map.values()) # to just get values()
- for (item of map.entries()) # gives us same result as map

#======================= SET
# is a simplified version of an array that has removed the indexing system thus it can't have duplicated data
# no index, no duplicated value a collection of unique data
# doesn't store keys but still remembers the insertion order
- let arr = [1,2,3,1,2,3]
- let set = new Set(arr)
- set.add(4)
- set.delete(4)
- set.has(4) // output: false
- set.clear()

# set can be turned into array 
- [...set]
- Array.from(set)
# it also has methods of .keys(), values() & entries() but there is no logic in using them 

# application of set is in merging arrays with duplicated data
- let merged = [...new Set([...arr1, ...arr2])]

#========================= Symbol
# to help us avoid naming collision the 7'th primitive data type came by ES
# Symbol has one purpose which is serving as property name in an object
- let s1 = Symbol(['a description or tag to identify symbol']) # it's very important that we just invoke it and not newing it
- s1.description() # to get it's description

# every invocation of symbol will give us a unique value and they are not a symbol wrapper object and thus we don't get any 
auto complete suggestion they are just have a __proto__ property that points to symbol wrapper object(Symbol.prototype)
- let s2.Symbol()
- sâ˜º1 === s2 // output: false

- Symbol.for('apple') # is another alternative to create symbol which gets a key
# symbol.for difference is it looks for key and if it has been before it just points to that in the next repeats ex:
- sf1 = Symbol.for('apple)
- sf2 = Symbol.for('apple')
- sf1 === sf2 // output: true

# to get key value of symbol
- Symbol.keyFor(sf1) // output: 'apple'

# as symbol is a computed value we must put it inside square brackets []
- let collection = {
    a: 1,
    b: 2, 
    [Symbol(c)]: 3
}

# Symbol will be put inside the object but will not show inside output of for( in ) because symbol properties are not enumerable

# to get symbols of an object we only can use: 
- let allSymbols = Object.getOwnPropertySymbols(collection)
- console.log(collection[allSymbols[0]])

# string, array, map & set can be used by for ( of ) because they all have Symbol.iterator in their prototype
which is an api function that works with for ( of ) in array it points to the values() method
we can't use objects with 'for of ' because they do not have Symbol.iterator to enable this api

# js wanted to add an api to str, map, set & array to make them iteratable but also wanted to give developers the freedom 
to choose names in prototype without collision of names so they name it as a Symbol 
and put this api inside iterator property of Symbol function  the Symbol.iterator is one of the well known symbols ()

: well known Symbol : symbol values stored in properties of the Symbol function that js uses them to name certain built-in
api methods or properties

# trick to get only keys or values in 'for of' by setting it's iterator to 
- Map.prototype[Symbol.iterator] = Map.prototype.values
- Map.prototype[Symbol.iterator] = Map.prototype.keys

# ========================================= Iteration Protocoles

1- iterable protocole (is for objects) 

# iterable protocol demands object to have a function names Symbol.iterator which can't have arguments and must return 
an object(iterator object) 

2- iterator protocol # rules for iterator object

it should have next() method that must return an object with atleast two properties 

1- done (boolean)
true means every value of the sequence has been output and iteration has reached an end
false means there are still values left in the sequence

2- vlaue

# we can run next() method manually which gives us elements one by one till end but it's very desirable to 
use it with 'for of' to make this process auto
# if we run next() manually the 'for of' will return undefined because the next() is done already

# =============our custom iterator=============
let arr = ['a', 'b', 'c']

arr.prototype[Symbol.iterator] = function () {
    let that = this
    let index = 0

    return {
        next() {
            return {
                if (index < that.length) {
                    return {
                        value: that[index++].toUpperCase(),
                        done: false
                    }
                } else {
                    return {
                        value: undefined,
                        done: true
                    }
                }
            }
        }
    }
}

# =============== Generator object
conforms to both iterabale and iterator and can work with 'for of' and 'next' method

# an array is not iterator but is iterable and we can do something like
# entries(), values() & keys() are both iterable and return iterator
let arr = ['a', 'b', 'c']
let entries = arr.entries()

# so we can use entries by next()
arr.next() // output: error
entries.next() // output: a 

entries === entries[Symbol.iterator]() // output: true

# === generator function 
# they can be exited and re-entered without loosing data (variable bindings will be saved across re-enteraces)
saving this functions context is a very important job of the 'generator object'
- function* generator (i) {
    yield i;
    yield i+10
    # we use yield to divide function body into chunks 
    # the value behind yield will be output by next() method
}

# when invoking generator function the body won't run and it just returns an iterator object
and every time we use next() a chunk of body will execute

# what you put behind yield will be assigned to the 'value' property of iterator

# '.return()' will end the iteration in cases like wrong id or something we wanna use
generator.return('a message to put inside value') // output {value: 'a message to put inside value', done: true}

# alternative to end iteration ahead of time is to use throw method 
generator.throw(new Error('something is wrong))

# if we want to catch error we should put our yeilds inside 'try catch' 
and the generator must be next() atleast once for it to catch

# .next() method can also get argument to put inside 'value' property but must make sure that 
won't pass any argument until the first next() is called and initiated the variable

# in the way ahead we use variables as placeholders after initation to get the arguments
function* customizeMyCar(obj){
    let brand = yield 'customize my car'
    obj.brand = brand
    let model = yield 'brand added'
    obj.model = model
    let engine = yield 'model added'
    obj.engine = engine
}

# ============= yield
with astrisk behind the yield it can handle an out put iterables
- yield* [1, 2, 3] // output: 1 \n 2 \n 3
- yield* generator() // output: output code chunks (yields) of the generator function whick returns an iterable     

#===================== Promises
promise: is an object that represent the execution result of an asynchronous operation

# promise.prototype has built-in methods of .then(), .catch(), .finally()

: promise.length property : always returns '1' which is numbers of arguments that a promise constructor  needs 
'a callback' that we call it here 'executer function'

: promise states : 
1- pending : is initial state 2-fulfulled: async operation is succeed 3-rejected failed

# fulfill and reject are alson called 'settled promise' and once it's settled the finally() will trigger

# browser alternative names for promise terms
promise state == PromiseStatus
fulfilled state == ResolvedStatus
success value == PromiseValue

: failure reason : the value that we pass to reject() function

: onFulfilled : the name of callback on 'then()' method
: onRejected: the name of callback on 'catch()' method
: onFinally: the name of callback on 'finally()' method
: success value : what we pass to resolve() function
: failure reason : what we pass to reject() function

# we can remove catch method because it's just a shortcut for: 
promiseFunction.then((res, rej)=>{}, (err)=>{console.log(err )})

: thenable object : is an object with a method under the name 'then' it only works with the resolve function
po = function() {
    new Promise((resolve, reject) => {
        resolve({
            then((resolve, reject) => {
                console.log('this is from thenable object which is promise still pending until this returns answer')
                reject('the object wants to answer reject for example')
            })
        })
    })
}

# best way to run multiple promises together is to put them in array and iterate over that by 'for of' or 'forEach'

# to find fastest promise we use Promise.race([p1,p2,p3]) which is owned by promise constructer and
it takes iterable as argument value and returns just the first settled promise

Promise.allSettled : waits for all promises to respond and returns a resolved promise with Promise value that is 
an array of settled promises then we can do whats next by attaching .then() to it

: Promise.all([p1,p2,p3]) : use it when we want all promises get resolved and we can control the output order of promises
in case one of promises of Promise.all() gets rejected the output will just be the rejected promise

# javascript callbacks are treated in non-blocking way 
for example if we have console.log before and after setTimeout, the logs print and whenever the time comes 
the log in setTimeout prints

#======================= Reflect Obj
13 static methods that intercept(prevent, stop) javascript operations
reflect is not a constructor so we cant new or invok it
methods:
1- Reflect.apply(): is an alternative to Function.prototype.apply() we implement it:
Reflect.apply(func, targetObj, [arg1, arg2])

2- Reflect.has(obj, 'property'): replaces 'in' operator
: in operator : check if an object has some property or not  ``` 'title' in obj // output: false ```

3- Reflect.deleteProperty(obj, 'property')
: delete operator : to remove a property from an object ``` delete obj.id // output: true```

4- Reflect.construct(obj, [arg1, arg2]): replaces the 'new' operator and returns us an object
5- .defineProperty() 
6- get: Æ’ ()
7- getOwnPropertyDescriptor: Æ’ getOwnPropertyDescriptor()
8- getPrototypeOf: Æ’ getPrototypeOf()
9- isExtensible: Æ’ isExtensible()
10- ownKeys: Æ’ ownKeys()
11- preventExtensions: Æ’ preventExtensions()
12- set: Æ’ ()
13- setPrototypeOf: Æ’ setPrototypeOf()
14- Symbol(Symbol.toStringTag): "Reflect"

#========================== PROXY
use it to define custom behaviour for fundamental operations
in other words we can customize JS at language level

PROXY Terminology:
1- handler: object that contains traps
2- traps: methods that we use to intercept user operations and redefine the results of user operations
    has 13 methods named like reflect methods
3- target: the Object, funciton or constructor which PROXY virtualizes it (we want to PROXY)

- var p = new Proxy(target, handler)

#================= trap methods
let car = {
    engine: 'petrol',
    gearbox: 'manual',
    _id: 1984
}

let carProxy = new Proxy(car, {
    get(car, property, receiver) {
        # receiver points to the carrent proxy object or the object that uses proxy as its prototype
        
        if (property === 'engine') {
            return target[property].toUpperCase()
        } else if( property === 'receiver') {
            return receiver
        } else {
            return 'access denied ...'
        }
    }
}

let newObj = Object.create(carProxy)

# in real life we use GET trap to make private properties

# inside handler object
- {
    get (target, property, receiver) {
    
    if (property[0] === '_') return 'access denied'
    target[property]
  },
  set (target, property, value, receiver) {
      if (property[0] === '_') throw 'You cannot set this property'
      target[property] = value.toUpperCase()
  }, 

   has (target, property) {
       if(property[0] === '_') return false
       Reflect.has(target, property)
   },

   deleteProperty (target, property) {
       if (property[0] === '_') return false
       Reflect.deleteProperty(target, property)
   }
}

#* ================ important : when using proxy as object prototype be carefull about 'traps' because child will inherit them
# when we create an object from a Proxy the obj.__proto__ will not give us the rusult that we want 
it either points to simple Object prototype or gets restricted by our 'get trap'
so to solve this always use: 
- Object.getPrototypeOf(obj)
    or
- Reflect.getPrototypeOf(obj)

# also when adding property to the child object from Proxy the property will add to proxy and not the child object
because of our 'set trap' to solve this we should use:
- Object.defineProperty(obj, 'propName', {value: 'propValue'})
    orz
- Reflect.defineProperty(obj, 'propName', {value: 'propValue'})

# ==================== defineProperty()
properties has decriptor that we can control them in proxy and also when defining property by defineProperty() ex:

let proxy = new Proxy({}, {
    defineProperty (target, prop, descriptor) {
        # must return a boolean but false won't intercept for not saving
        descriptor.configurable = true  // must be allways true when adding in both sides( 1- trap 2- defining property outside trap)
        descriptor.enumerable = true/false
        descriptor.value = 'changed the value that use sent to something else'
        descriptor.writable = false
        Reflect.defineProperty(target, prop, descriptor)

    }
})

- proxy.msg = 'hello'  // this will set all descriptors true

Object.defineProperty(proxy, 'msg', {
    configurable: true // must be true otherwise we'll get error`,
    writable: false,
    enumerable: true,
    value: 'hello'
})


#============ apply() trap
intercepts the apply() call on a proxy, it also affects the call()
insie the apply trap this_argument is undefined
{
    apply (target, this_arg, arg_list) {
        this_arg = {title: 'hello'}
        arg_list[0]++
        arg_list[1]++
        return target.apply(this_arg, arg_list)
    }
}


#================ construct() trap
# a constructor can have three types of property: -instance -prototype -static
# new_target helps us to create static properties in proxy and not the instanced object
# having arguments list in proxy helps keeping data validation outside of constructor

{
    construct (target, arg_list, new_target //points to proxy object) {
        new_target.static_prop = 'static property'
        arg_list[0] = arg_list[0].toUpperCase()
        let obj = new target(...arg_list)
        obj.id = 1984

        return obj
    }
}

#==================== Revocalbe Proxy
making a proxy that can be revoked(removed and get unaccessible)
make new proxy is by default revocable: false
to make it revocable:

let revocable = Proxy.revocable(target, handler) // this gives back an object that has -revok & -proxy in it

let proxyObj = revocalbe.proxy

revocalbe.revoke() 
#when we revoke tha proxy object still exists
but it's Target and Handler will remove and IsRevoked will change to true and we can't use proxy anymore


#=========================json
JSON.strigify() & JSON.parse() alternatives are qs.strigify() & qs.parse()

#================= CommonJs 
it's a community developed js modular solution to break file into different files and 
link them back together and it's current default for nodejs but future is 'import export'
the other solution are : 
requirejs which is built on AMD(Asynchronous Modular Definition) 
in china there is CGS which conforms to CMD(Common Modular Definition)
those are all community developed Unlike ES6 'import export'
import exoprt is official way of es6 for modularity

#================ 'require' properties
: resolve : 'require.resolve('./mymodule')' returns absolute path of the module that we are exporting
'require' has it because it always converts our relative paths to absolute and uses that

: main : it is the current module that we are calling require in it so thus: 
require.main === module // output: true

: cache : it chaches the required modules so when we repeat the require it won't do the repeated work and brings it 
from cache it stores an object of current module and required module and the exported module is cached there for example 
there is chache property that has :
- require.cache.<absolute path of current module>
- require.cache.<absolute path of required module>

and we can access the cached like this
- require.cache[require.resolve('./myModule')].exports

and we can change or delete to get updated module
- require.cache[require.resolve('./myModule')].exports = 'new value'
- delete require.cache[require.resolve('./myModule')].exports = 'new value'

#* NODEJS treats every js file as a module  

#====================== 'module' properties
: id : absolute address of file which for current file is ' . ' dot
: children : array of all modules that are included in current file
- module.children[0].exports
# this is how 'require' accesses exports of a linked file

# circular dependency: in computer science it's a bad word and often it's an infinite loop 
but in requiring two files in eachother there won't be a problem because it won't get executed twice 

- require('./a')
- require('./a')
# just runs 'a' module once

#===================== 'import export'
1- import gets hoisted thus the code in imported module runs before current file that imports it
2- must always declare it at the top and can't be inside funtion or if statement (gives us error`)

: import function :  to import based on conditions we can use import function 'import()'
import function won't be hoisted and returns a promise

: export : must be defined at top level (not inside function or statements) and has to types:
1- named export 2- default export

in named export: 
every value is exported with a name (function, class, variable), we can add as many named exports we want in a file
# when using named exports we should import it by curly brackets

# we cannot directly export a variable or constant and should put it inside curly brackets
let msg = 'hello'
export {msg as word}
export let msg = 'hello', id = 1984
import * as obj from './b'

# to use enable ES6 modules in nodejs

1-rename file extion to '.mjs'
2- adding flag of experimental-modules
- node --experimental-modules a

2- default export:
in named export we have to know the name of exported things but in default we don't have this problem
but we can just have one default export in one module and if we need to export multiple we should put them 
in an array or an object

- export default [msg, id]

# we can directly export a value like string or number 

export default 1984

# we can also define it like: 
- export {msg as default}

#* export default sends the dynamic refrence of current value of variable
but named export sends dynamic refrence of the variable 
so if the variable gets changed we can have the change in the file we import it
- export let num_b = 0
- num_b++

#============ import export in browser
first we should have the html run by a bundler(babbel, webpack) or a web server then:

<script type='module'>
    import {msg} from 'myModule.js'
    # better to keep file extensions while using in web browser
</script>

# if using module function there is no need to define the script as module because it returns a promise
<script>
    import('./myModule')
    .then((value)=> {
        console.log(value.msg)
        #if export by default we use it like:
        console.log(value.default)
    })
</script>

# ================ Strict mode
for enabling:
1- make type module in script tage makes it Strict
2- using 'use strict' string
3- importing files into each other make auto strict mode by ES6

# we can not make block scope to strict mode it just works with function scope or global scope

# under strict mode we can't:
1- get global variables whitout pointing to it :
console.log(window.a )

2- this inside a function won't refrence to global unles we call function like:
window.myfunc()

3- deleting a global variable by 'delete' operator is illegal and throws error 
but without strict it's ok but just won't delete

4- can't call a function which is declared inside block scope (like if) from outside a block scope 

5- when using Octal numbers we should put 'O' behind(after) starting zero
let num = 0o123

#================= __proto__
obj.constructor.prototype == obj.prototype // output: true
obj.__proto__ == Object.prototype // output: true

#* if we want an object that is truly empty:
let myObj = Object.creat(null)

# if a function doesn't need argument the paranthesis will be optional when newing it

#================== Object constructor
create object wrapper for a given value

: object wrapper : which gives the primitive types ability to inheritance their special methods

# Object methods
Object.entries: turns an object into a 2D array first one is key second one is value
Object.keyst: gives array of keys
Object.values: gives array of values
Object.fromEntries(): transform back 2D array from 'entries method' to an object
Object.is(): check if two objects are pointing to same object or not

# we can set prototype by:
- obj.__proto__ = anotherObj
- Object.setPrototypeOf(obj, anotherObj)

# getting portotype of an object
- Object.getPrototypeOf(obj)

#creating an object with from custom prototype
Object.create(customProtyObj, opionalPropertyAttributes)
: property attributes : 
1-value: value of property; default: null
2- enumerable: working with 'for in'; default: false
3- writable: changing value; default: false
4- configurable: can we modify other property attributes, property value or delete property; default: false 

#expanding object (adding properties)
Object.assign(obj, {name: "Tom"})

# creating object in defferent ways are important:
- Object.create({msg: 'hello'}) // creates an object that inherits msg and it's not part of it
- new function(){this.msg = 'hello'} // creates an object which owns msg property

# Object.getOwnPropertyDescriptor(targetObject, propertyName) : gives descriptors (property attributes)
of a property just in target object (because of Own ) not the inherited ones

- getOwnPropertyDescriptors(obj): gives all properties descriptors

# defining property 
- Object.definePropery(targetObj, propertyName, {
    value: 2000,
    enumerable: true
})

- Object.defineProperties(targetObj, {
    color: {
        value: 'blue'
    },
    location: {
        value: 'iran'
    }
})

# preventing Object from getting new property
preventions are leveled soft to hard:
1- Object.preventExtensions(obj); soft
still can add to prototype chain and the object will inherit that

2- Object.seal(obj); hard
like prevent but changes configurable property attribute of all own properties to into false
and we can change the value of property but we can't change the properties of it's prototype 
- Object.isSealed() // output: true
- Object.isExtensible() // output: false

3- Object.freeze(obj); medium
doesn't allow any changes
- Object.isFrozen(obj) // output: true
- Object.isExtensible(obj) // output: false
# we can still change the prototype and the object will inherit from it

#=================== Accessor Property two-way data bining
getter & setter : using them to retrive and set properties value
they are defined as methods but used as properties:
let obj = {
    msg: "this is message property",
    
    get access_msg () {
        return this.msg
    },
    set access_msg (arg) {
        this.msg = arg
    }
}

USAGE:
- obj.access_msg
- obj.access_msg = 'new message value'
# if call it as function we get an Error

another way to define accessors:

Object.defineProperty(obj, access_msg, {
    get(){return this.msg},
    set(arg){this.msg=arg},
    enumerable: true,
    configurable: false //because no one should be able to change accessors
})

#================== constructor
if we do Object.create(obj) from an object the new object will inherit the properties
if we want the properties be a part of new object we should use constructor object

# there are some types of properties:
1- Instance Properties: owned by the new object
2- Prototype: inherited by new object (mostly use to define props with costom attributes/accessors)
3- Static: won't be passed to the instance object at all
4- private properties: just inside constructor has access to it
and just constructor has access to it like all the variables 
that are defined inside a constructor function (can't get it by obj.prototype or obj.constructor properties)

# first letter of constructor must be capital by convention
let Car_constructor (engine, gearbox) {
    this.engine = engine // example of instance property
    this.gearbox = gearbox
    this.start = function () {
        console.log('engine on...')
    }
    this.rev_engine = function () {
        console.log('vroom... ')
    }

    let msg = 'hello' // example of private property
}

# to define properties that just are inside portotype
example of prototype properties:
Object.defineProperty(Car_constructor.prototype, 'mileage', {
    value: 1000,
    enumerable: true,
    writable: false,
    configurable: false
})

: static properties : they are defined just inside constructor and instance object won't affect them
Car_constructor.location = 'NewCastle

# to access it we must access it either by constructor property of instance object 
or setting an accessor property for it
- car_obj.constructor.location

let car_obj = new Car_constructor('Hybrid', 'Automatic)

# another way to define these different properties:
1- instance: this.msg = 'hello'
2- prototype: this.__proto__.msg = 'hello'
3- constructor(static property): this.constructor.msg = 'hello'

# it's recommended for better performance to define just instance porperties inside 
constructor functoin and define others outside function body seperately

#================ class
in ES6 class is just a syntax sugar and 'type of class' just returns a function 
which is like a constructor function but unlike function the class decleration won't be hoisted
so we can't new a class before it's decleration
- typeof myClass // output: function

# two ways to define class : 
1- Declaration
- class myClass{}

2- Expression 
# this way helps keeping code clean and concise
- let myClass = class{}

#* important difference of class and constructor function:
constructor functions 'writable' description is true 
which means we can reset prototype of our newed object or add to it
but in class the writable descriptor in prototype of newed object is false
- myClass.prototype = {test: 'this won't add to prototype'}

# it can be an improvement that is brout by class to protect the prototype of instanced objects

# type of methods in a class:
1- instance methods: //also named full syntax
- let start = function () {console.log(this.engine + 'is on...')}

2- property method: //also named shorter syntax
- rev_engine () {console.log(this.engine + 'vroom...')} // must define without function keyword

3- static methods: // can be defined with either full or shorter syntax
- static shut_engine () {console.log(this.engine)}

# we can also add getter and setter in class
- get access_engine () {return this.engine}
- set access_engine () {this.engine = arg}

# =========== Field
is a stage 3 experimental feature which are values that won't need user submission
and has two types:
1- public:
- plateOfCar = 'NE19 HA0'

2- private: starts with a hashtag
it can only be accessed by methods of class or accessors
- #id = 100

# problems of fields
1- it's still experimental
2- it shows private fields by logging instance object

# the best way to keep some private information is to define variable inside 
constructor function so it's only visible by constructor function and wont be 
passed to instanced object

class myClass {
    constructor() {
        let myHiddenValue = 1000
# to access it define a method that returns it \
        this.access_myHiddenValue = function () {return myHiddenValue}
    }
}

# Class extensions
: super method : is like a bridge from child class constructor to parent class constructore

# we can use super to extend a method from parent class but 
we can't extend instance methods by super this way we can protect our method 
and use it to make sure that child class either uses instance method or completly replaces it
- child_instance_method(){super.instance_method()} // returns error
- child_prototype_method(){super.prototype_method()}
- child_static_method(){super.static_method()}

# we can add functionality to types like 'Array' by creating child class from them 
class myArray extends Array{}

there comes a problem when using special methods like 'map' that returns new array 
to fix that we can use:
static [Symbol.species] () {
    return Array
}
# but this trick won't work on methods that change directly and won' return new array(like [2,3].reverse() method)

#* to prevent a constructor function being called without new we use target:
function Car (brand, model) {
    if (new.target) {
        this.brand = brand
        this.model = model
    } else {throw new Error('Car is a constructor , new it !!!)}
}

: new.target : will points to the target that is behind keyword new

#* we can also use new.target feature to protect parent class from being newed
class Child_class extends Parent_class {
    constructor(){
    if(new.target === Parent_class) throw 'Parent class cannot be newed!!!'
    this.brand = 'Petrol'
    }
}

: Mixin : mixing properties and methods from different classed and constructors into one class
extends in classes is a way of Mixin

- class Car_basics {
    constructor() {
        this.brand = 'Toyota'
        this.model = 'Camry'
    }
}

- function Petrol_engine (cls<target-class-to-change-it's-constructor>) {
    return class extends cls {
        constructor() {
            super()
            this.engine = 'Petrol'
        }
    }
}

- function Hybrid (cls<target-class-to-change-it's-constructor>) {
    return class extends cls {
        constructor() {
            super()
            this.engine = 'Hybrid'
        }
    }
}

- function Automatic_gearbox (cls<target-class-to-change-it's-constructor>) {
    return class extends cls {
        constructor() {
            super()
            this.gearbox = 'Automatic'
        }
    }
}

- function CVT_gearbox (cls<target-class-to-change-it's-constructor>) {
    return class extends cls {
        constructor() {
            super()
            this.gearbox = 'CVT'
        }
    }
}

# USAGE:
- let targetClass = Automatic_gearbox(Petrol_engine(Car_basics))
- let car = new targetClass

#=========================== Data Structure
science of storing and managing data

Queue: helps stack manage unexecuted tasks
follows FIFO principle
enqueue: adding to Queue
dequeue: removing from queue
front pinter: points to first task in queue in other words
task that is being pointed by front pointer will be executed first
rear pointer: points to last task in queue

Stack: area that tasks are executed and completed
opposite of Queue follows LIFO principle

frame: refers to stack tasks
push: adding to stack
pop: removing from stack

# bottom of stack is fixed so we only need one pointer to manage it called 'top pointer'

Heap: unordered area of memory where elements are added or removed in any order(fifo, lifo) 
so we never manage tasks using heap but this feature(unorder) gives lots of felexibility in terms of data storage
we use heap to store objects because their size are often unpredictable

** javascript is a single-thread language
process: execution of an entire program
thread: entitiy within a process
one process is made of several threads

for better performance js fakes or simiulates the behaviour of a multi-thread language 
synchronous code: these tasks are blocking and executed in the same order they are defined
asynchronous code: they will be skipped and executed later

#======================== how js does async
to make sure skipped code won't be forgotten
js adds it to 'task queue'
after all synchronous codes are executed js goes to task queue 
and clears it by FIFO but if the result is not ready it will be skipped

#======================== Micro & Macro tasks
micro task queue has higher priority than Macro task queue
and micros will be executed before macro ones

a callback in a setTimeout() is a Macro task
.then(), .catch() & .finally() methods are Micro tasks

#======================= event loop
js runs programs with event loop depending on program design 
there might be several event loops rounds 
# important:
there is only one Macro Task Queue but
each event loop has it's own Micro Task Queue
event loop start with execution of first sync task in current scope
and ends with clearing the micro task queue

types of queue in priority order:
1- nextTick queue
2- micro queue
3- macro queue
#==================== third type of queque process.nextTick() Queue
will add a callback to next tick queue

#================= Tail call optimization
this technique greatly imporves efficiency of recursion programs
an completely prevents stackoverflow caused by recursion

to do this we must return the function at the end (tail) of the function 
and it return must not be relied on something that is defined inside function and if we need 
something just pass it as argument to returned function like this:

function factorial (num, total = 1) {
    if (num === 1) return total
    return factorial(num-1, total*number)
}

# this way we make sure there is only one frame in the stack 

: Encapsulation : wrap a series of codes into a sealed space to protect better and reuse them
: polymorphism : can be used by different ways like console can output any type or iterator works with array, object, enteraces

#============================ Reseting vs Modifying values
we cannot modify a primitive value, we just create a new value and replace it
let msg = 'hello'
msg = msg.toUpperCase()
# without assignment the msg uppercase won't affect the variables value

# when modifying a value js engine will search current object to find variable 
if it's not there it goes down the chain to find it and if it isn't found it won't be created
    BUT
# in resetting a value  js only searches current object and won't go to prototype chain and if
it's not found it will be created

# function is a typeof refrence value but we cannot modify it and it can just be replaced

#====================== Douglas Crawfords program: works like Object.create(obj)
- let a = {msg: 'hello', list:[1,2,3]}
- function outer (obj) {
    function inner () {}
    inner.prototype = obj.prototype
    return new inner
  }
- let myprogram = outer(a)


#============================= Combination of two constructor (a genius and creative inheritance p)
- function Parent () {
    this.msg = 'hello'
    this.list = [1, 2, 3]
}

- function Child () {
    Parent.call(this)
}

#====================== typeof & instaceof
: typeof : tells us the data type can be used as operator or an function so the paranthesis behind it is optional
in total it returns us 7 types of results : (1- array 2- Set 3- Map 4- null) as object type data
undeclared variables and empty variables will return 'undefined'

: instanceof : tells us if a given object is created from a certain constructor of not
it also searched down the prototype chain so if it's inherited from another object that would also
give us true
- targetObject instanceof costructorObject
- targetObject instanceof Object // output: true

* special case of creating null
- let b = Object.create(null)
- b instanceof Object // output: false

#============================ Shallow Copy an object
# will only copy memmory addres of refrence type values
- let a = Object.assign({}, obj)
# this way a will share the refrence values with obj and changing a will affect objects 
refrence values (not primitive ones)

#========================== Deep Copy an object
# will also copy refrence type values this way the source object won't be affected
- function deepCopy (source) {
    if (typeof source !== 'object' || source === null) throw 'illegal value

    let copy = Array.isArray(source) ? [] : {}
    for (let key in source) {
        
        if (typeof source[key] === 'object' && source[key] !== null)
            //reference type
            copy[key] = deepCopy(source[key])
        
        //primitive type
        copy[key] = source[key]
    }
}

# =========== recreating by tail call optimization
- function deepCopy (target, source) {
    if (typeof target !== 'object' || source === null) throw 'Illegal first argument value'
    if (typeof source !== 'object' || source === null) throw 'Illegal second argument value'

    for (let key in source) {
        if (typeof source[key] === 'object' && source[key] !== null) {

            if (Array.isArray(source[key])) target[key] = []
            else target[key] = {}

            deepCopy(target[key], source[key])

        } else {
            target[key] = source[key]
        }   
    }
    return target
}


#========================== Garbage collection
a piece of data is made of two parts:
1- data name: to remove it we need to remove it's scope
thats why we shouldn't define variables in global scope and that way 
we should wait untill the program execution is done but if we define in function scope 
it will remove after function execution

2- data values: are removed by garbage collector automatically

to remove a piece of data from memory we need to remove both data names and values

# before 2012 js used reference count to decide whether a data value should be regard as garbage or not

: Reference Count : is the number of names of values associated with, the reference count of a primitive value
can only be 1 or 0
- let msg = 'hello' // now it's referece count is 1
- msg = null // now it's referece count is 0 which means will be removed by garbage collector

#* an Object is reference type and it's reference count can be bigger than 1 
- let a = {title: 'hello'} // reference count of object in memmory is 1
- let b = a // reference count changed to 2
- a = null // reference count is 1(b is still referring to it) and won't be deleted
- b = null // reference count is 0 and object will be removed by garbage collector

: Memory Leak : when we forgot to null the variables that we don't need anymore
they will stay alive till the end 

: Circular Reference : we should avoid it because makes an endless loop of self reference and causes stack overflow
- let a = {msg: 'hello'} 
- a.ref = a

# even after nulling object a it won't be removed and waste our memmory
- a = null

# after 2012 JS has replaced 'reference count' with 'mark and sweep algorithm' 
: mark and sweep : once a piece of data has become inaccessible it wil be regarded as a piece of garbage
and removed from memmory and if reference count isn't zero it will remove the variable anyway
= a = null // this will be deleted even if reference count isn't zero